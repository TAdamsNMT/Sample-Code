Script started on Fri 18 Nov 2016 11:33:12 AM MST
[1m[7m%[27m[1m[0m                                                                                ]2;student@HAL: ~/Dropbox/cs113/lab9]1;..ox/cs113/lab9[0m[27m[24m[J[01;32mâžœ  [36mlab9[00m [K[?1h=[?2004hscript bincalc.script[21Dexit                 [17Dvim bincalc.c[13Dvalgr[2Cd --leak-check=full ./bincalc[36Dmake                                [32D[?1l>[?2004l
]2;make]1;makeclang -g -Wall dllist.o bincalc.c -o bincalc
[1m[7m%[27m[1m[0m                                                                                ]2;student@HAL: ~/Dropbox/cs113/lab9]1;..ox/cs113/lab9[0m[27m[24m[J[01;32mâžœ  [36mlab9[00m [K[?1h=[?2004hmakescript bincalc.script[21Dexit                 [17Dvim bincalc.c[13Dvalgr[2Cd --leak-check=full ./bincalc[?1l>[?2004l
]2;valgrind --leak-check=full ./bincalc]1;valgrind==2646== Memcheck, a memory error detector
==2646== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==2646== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==2646== Command: ./bincalc
==2646== 
enter word size: 1
unsigned values[y/N]: n y
enter binary expression: 1 & 0
1
&
0
-
0
flags
carry: 0
overflow: 0
sign: 0
parity: 1
zero: 1
decimal: 0

do you want to continue [Y/n]?: y
enter word size: 64
unsigned values[y/N]: 
==2646== Conditional jump or move depends on uninitialised value(s)
==2646==    at 0x401421: main (bincalc.c:112)
==2646== 
==2646== Conditional jump or move depends on uninitialised value(s)
==2646==    at 0x40142E: main (bincalc.c:112)
==2646== 
enter binary expression: 11 + 1
0000000000000000000000000000000000000000000000000000000000000011
+
0000000000000000000000000000000000000000000000000000000000000001
----------------------------------------------------------------
0000000000000000000000000000000000000000000000000000000000000100
flags
carry: 0
overflow: 0
sign: 0
parity: 0
zero: 0
decimal: 4

do you want to continue [Y/n]?: y
enter word size: 4
unsigned values[y/N]: 
enter binary expression: 1000 + 1^[[D^[[D           | 1
1000
|
0001
----
1001
flags
carry: 0
overflow: 0
sign: 1
parity: 1
zero: 0
decimal: -7

do you want to continue [Y/n]?: y
enter word size: 4
unsigned values[y/N]: 
enter binary expression: 1000 + 1111
1000
+
1111
----
0111
flags
carry: 1
overflow: 1
sign: 0
parity: 0
zero: 0
decimal: 7

do you want to continue [Y/n]?: y
enter word size: 8
unsigned values[y/N]: 1100 ^ 1010
enter binary expression: 1100 ^ 1010
00001100
^
00001010
--------
00000110
flags
carry: 0
overflow: 0
sign: 0
parity: 1
zero: 0
decimal: 6

do you want to continue [Y/n]?: y
enter word size: 8
unsigned values[y/N]: y
enter binary expression: 11001100 & 10001000
11001100
&
10001000
--------
10001000
flags
carry: 0
overflow: 0
sign: 1
parity: 1
zero: 0
decimal: 136

do you want to continue [Y/n]?: y
enter word size: 8
unsigned values[y/N]: n
enter binary expression: 1 - 10
00000001
+
11111110
--------
11111111
flags
carry: 0
overflow: 0
sign: 1
parity: 1
zero: 0
decimal: -1

do you want to continue [Y/n]?: y
enter word size: 1999
error in word size, must be between 1 and 64
enter word size: -4
error in word size, must be between 1 and 64
enter word size: 4
unsigned values[y/N]: banana
enter binary expression: 1000 ] 20  1000
error in operator. retry
enter word size: 4
unsigned values[y/N]: q
enter binary expression: 2000 - 1995
error in input -- something other than a 1 or 0 entered
error in first operand. retry
enter word size: 4
unsigned values[y/N]: 
enter binary expression: 10000 - 1
error in input -- length is greater than word size
error in first operand. retry
enter word size: 4
unsigned values[y/N]: 
enter binary expression: 1000 - 1995
error in input -- something other than a 1 or 0 entered
error in second operand. retry
enter word size: 4
unsigned values[y/N]: 
enter binary expression: 1000 - 10000
error in input -- length is greater than word size
error in second operand. retry
enter word size: 4
unsigned values[y/N]: 
enter binary expression: 1000 - 1000
1000
+
1000
----
0000
flags
carry: 1
overflow: 1
sign: 0
parity: 1
zero: 1
decimal: 0

do you want to continue [Y/n]?: n
Goodbye
==2646== 
==2646== HEAP SUMMARY:
==2646==     in use at exit: 0 bytes in 0 blocks
==2646==   total heap usage: 317 allocs, 317 frees, 9,664 bytes allocated
==2646== 
==2646== All heap blocks were freed -- no leaks are possible
==2646== 
==2646== For counts of detected and suppressed errors, rerun with: -v
==2646== Use --track-origins=yes to see where uninitialised values come from
==2646== ERROR SUMMARY: 14 errors from 2 contexts (suppressed: 0 from 0)
[1m[7m%[27m[1m[0m                                                                                ]2;student@HAL: ~/Dropbox/cs113/lab9]1;..ox/cs113/lab9[0m[27m[24m[J[01;32mâžœ  [36mlab9[00m [K[?1h=[?2004heexit[?1l>[?2004l
]2;exit]1;exit
Script done on Fri 18 Nov 2016 11:39:46 AM MST
